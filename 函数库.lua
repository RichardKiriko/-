local tr = aegisub.gettext
script_name = tr("Add function")
script_description = tr("Add function to selected line")
script_author = "kiriko"
script_version = "1.2"

include("unicode.lua")

function add_function(subtitles, selected_lines, active_line)
	lable_gui =	{
		{class="label",x=2,y=0,width=1,height=1,label="本插件用于快速添加部分实用函数"},
		{class="label",x=2,y=1,width=1,height=1,label="目前支持的函数及作者如下："},
		{class="label",x=2,y=2,width=1,height=1,label="abs_random"},
		{class="label",x=2,y=3,width=1,height=1,label="autotags"},
		{class="label",x=2,y=4,width=1,height=1,label="double_loop"},
		{class="label",x=2,y=5,width=1,height=1,label="text_to_shape"},
		{class="label",x=2,y=6,width=1,height=1,label="text_to_pixels"},
		{class="label",x=2,y=7,width=1,height=1,label="shape_bounding"},
		{class="label",x=2,y=8,width=1,height=1,label="bounding_an"},
		{class="label",x=2,y=9,width=1,height=1,label="shape_scale"},
		{class="label",x=2,y=10,width=1,height=1,label="utf8【haiyang】"},
		{class="label",x=2,y=11,width=1,height=1,label="lighting【haiyang】"},
		{class="label",x=2,y=12,width=1,height=1,label="在选中的行的特效栏输入相应函数名即可添加"}
		}
		btn,res=_G.aegisub.dialog.display(lable_gui,{"OK","Cancel"})
		if btn=="Cancel" then 
			aegisub.cancel()
		end
	for z, i in ipairs(selected_lines) do
		local l = subtitles[i]
		if l.effect == "double_loop" then
			l.text=[===[function double_loop(loop_n,n2,tbl) maxloop(loop_n*n2) li=math.ceil(j/loop_n) loop_i=(j-1)%loop_n+1 if tbl ~= nil then if j == 1 then lr={} end if loop_i == 1 then lr[li]={} for i=1,#tbl do lr[li][tbl[i][1]]=tbl[i][2] end end end return"" end]===]
	
		elseif l.effect == "abs_random" then
			l.text=[===[function abs_random(min,max) return math.random(min,max)*2*(math.random(0,1)-0.5) end]===]
	
		elseif l.effect == "autotags" then
			l.text=[===[function autotags(Intervalo,Dato1,Dato2,Pause,st,et) if st == nil then st=0 end if et == nil then et=line.duration end local tags="" local SUERTE = 0 local CONTADOR = 0 local ARREGLO = {Dato1,Dato2} local count = math.ceil((et-st)/(Intervalo+Pause)) for i = 1, count do CONTADOR = i if Dato1 and Dato2 then if CONTADOR%2 ==0 then SUERTE = ARREGLO[1] else SUERTE = ARREGLO[2] end end tags = tags .."\\t(" ..st+(i-1)*(Intervalo+Pause).. "," ..st+i*Intervalo+Pause*(i-1).. ",\\" ..SUERTE..")".."" end return tags end]===]
	
		elseif l.effect == "text_to_shape" then
			l.text=[===[function text_to_shape(text,style) shape_text=_G.Yutils.decode.create_font(style.fontname,style.bold, style.italic, style.underline, style.strikeout,style.fontsize,style.scale_x/100,style.scale_y/100,style.spacing).text_to_shape(text) shape_text=string.gsub(shape_text,"c","") return shape_text end]===]
	
		elseif l.effect == "text_to_pixels" then
			l.text=[===[function text_to_pixels(text,style) texts=_G.Yutils.decode.create_font(style.fontname,style.bold, style.italic, style.underline, style.strikeout,style.fontsize,style.scale_x/100,style.scale_y/100,style.spacing).text_to_shape(text) texts=string.gsub(texts,"c","") pixels=_G.Yutils.shape.to_pixels(texts) return pixels end]===]
	
		elseif l.effect == "shape_bounding" then
			l.text=[===[function shape_bounding(ass_shape) local x1,y1,x2,y2=_G.Yutils.shape.bounding(ass_shape) local tbl={left=x1,right=x2,center=(x1+x2)/2,top=y1,bottom=y2,middle=(y1+y2)/2,width=x2-x1,height=y2-y1} return tbl end]===]
	
		elseif l.effect == "bounding_an" then
			l.text=[===[function bounding_an(ass_shape,mode) local x1,y1,x2,y2=_G.Yutils.shape.bounding(ass_shape) local b={left=x1,right=x2,center=(x1+x2)/2,top=y1,bottom=y2,middle=(y1+y2)/2,width=x2-x1,height=y2-y1} if mode == 7 then new_shape=_G.Yutils.shape.move(ass_shape,-b.left,-b.top) elseif mode == 1 then new_shape=_G.Yutils.shape.move(ass_shape,-b.left,-b.bottom) elseif mode == 2 then new_shape=_G.Yutils.shape.move(ass_shape,-b.center,-b.bottom) elseif mode == 3 then new_shape=_G.Yutils.shape.move(ass_shape,-b.right,-b.bottom) elseif mode == 4 then new_shape=_G.Yutils.shape.move(ass_shape,-b.left,-b.middle) elseif mode == 5 then new_shape=_G.Yutils.shape.move(ass_shape,-b.center,-b.middle) elseif mode == 6 then new_shape=_G.Yutils.shape.move(ass_shape,-b.right,-b.middle) elseif mode == 8 then new_shape=_G.Yutils.shape.move(ass_shape,-b.center,-b.top) elseif mode == 9 then new_shape=_G.Yutils.shape.move(ass_shape,-b.right,-b.top) end return new_shape end]===]
	
		elseif l.effect == "shape_scale" then
			l.text=[===[function shape_scale(ass_shape,xscale,yscale) if xscale == nil then xscale = 1 else xscale = xscale/100 end if yscale == nil then yscale = 1 else yscale = yscale/100 end return _G.Yutils.shape.filter(ass_shape,function(x,y) return x*xscale,y*yscale end) end]===]
	
		elseif l.effect == "utf8" then
			l.text=[===[local byte = _G.string.byte local char = _G.string.char local dump = _G.string.dump local find = _G.string.find local format = _G.string.format local len = _G.string.len local lower = _G.string.lower local rep = _G.string.rep local sub = _G.string.sub local upper = _G.string.upper function utf8charbytes (s, i) i = i or 1 if _G.type(s) ~= "string" then _G.error("bad argument #1 to 'utf8charbytes' (string expected, got ".. _G.type(s).. ")") end if _G.type(i) ~= "number" then _G.error("bad argument #2 to 'utf8charbytes' (number expected, got ".. _G.type(i).. ")") end local c = byte(s, i) if c > 0 and c <= 127 then return 1 elseif c >= 194 and c <= 223 then local c2 = byte(s, i + 1) if not c2 then _G.error("UTF-8 string terminated early") end if c2 < 128 or c2 > 191 then _G.error("Invalid UTF-8 character") end return 2 elseif c >= 224 and c <= 239 then local c2 = byte(s, i + 1) local c3 = byte(s, i + 2) if not c2 or not c3 then _G.error("UTF-8 string terminated early") end if c == 224 and (c2 < 160 or c2 > 191) then _G.error("Invalid UTF-8 character") elseif c == 237 and (c2 < 128 or c2 > 159) then _G.error("Invalid UTF-8 character") elseif c2 < 128 or c2 > 191 then _G.error("Invalid UTF-8 character") end if c3 < 128 or c3 > 191 then _G.error("Invalid UTF-8 character") end return 3 elseif c >= 240 and c <= 244 then local c2 = byte(s, i + 1) local c3 = byte(s, i + 2) local c4 = byte(s, i + 3) if not c2 or not c3 or not c4 then _G.error("UTF-8 string terminated early") end if c == 240 and (c2 < 144 or c2 > 191) then _G.error("Invalid UTF-8 character") elseif c == 244 and (c2 < 128 or c2 > 143) then _G.error("Invalid UTF-8 character") elseif c2 < 128 or c2 > 191 then _G.error("Invalid UTF-8 character") end if c3 < 128 or c3 > 191 then _G.error("Invalid UTF-8 character") end if c4 < 128 or c4 > 191 then _G.error("Invalid UTF-8 character") end return 4 else _G.error("Invalid UTF-8 character") end end function utf8len (s) if _G.type(s) ~= "string" then for k,v in _G.pairs(s) do _G.print('"',_G.tostring(k),'"',_G.tostring(v),'"') end _G.error("bad argument #1 to 'utf8len' (string expected, got ".. _G.type(s).. ")") end local pos = 1 local bytes = len(s) local length = 0 while pos <= bytes do length = length + 1 pos = pos + utf8charbytes(s, pos) end return length end function utf8sub (s, i, J) J = J or -1 local pos = 1 local bytes = len(s) local length = 0 local l = (i >= 0 and J >= 0) or utf8len(s) local startChar = (i >= 0) and i or l + i + 1 local endChar = (J >= 0) and J or l + J + 1 if startChar > endChar then return "" end local startByte,endByte = 1,bytes while pos <= bytes do length = length + 1 if length == startChar then startByte = pos end pos = pos + utf8charbytes(s, pos) if length == endChar then endByte = pos - 1 break end end if startChar > length then startByte = bytes+1 end if endChar < 1 then endByte = 0 end return sub(s, startByte, endByte) end function utf8reverse (s) if _G.type(s) ~= "string" then _G.error("bad argument #1 to 'utf8reverse' (string expected, got ".. _G.type(s).. ")") end local bytes = len(s) local pos = bytes local charbytes local newstr = "" while pos > 0 do local c = byte(s, pos) while c >= 128 and c <= 191 do pos = pos - 1 c = byte(s, pos) end charbytes = utf8charbytes(s, pos) newstr = newstr .. sub(s, pos, pos + charbytes - 1) pos = pos - 1 end return newstr end function utf8char(unicode) if unicode <= 0x7F then return char(unicode) end if (unicode <= 0x7FF) then local Byte0 = 0xC0 + _G.math.floor(unicode / 0x40); local Byte1 = 0x80 + (unicode % 0x40); return char(Byte0, Byte1); end; if (unicode <= 0xFFFF) then local Byte0 = 0xE0 + _G.math.floor(unicode / 0x1000); local Byte1 = 0x80 + (_G.math.floor(unicode / 0x40) % 0x40); local Byte2 = 0x80 + (unicode % 0x40); return char(Byte0, Byte1, Byte2); end; if (unicode <= 0x10FFFF) then local code = unicode local Byte3= 0x80 + (code % 0x40); code = _G.math.floor(code / 0x40) local Byte2= 0x80 + (code % 0x40); code = _G.math.floor(code / 0x40) local Byte1= 0x80 + (code % 0x40); code = _G.math.floor(code / 0x40) local Byte0= 0xF0 + code; return char(Byte0, Byte1, Byte2, Byte3); end; _G.error 'Unicode cannot be greater than U+10FFFF!' end local shift_6 = 2^6 local shift_12 = 2^12 local shift_18 = 2^18 function utf8unicode(str, i, J, byte_pos) i = i or 1 J = J or i if i > J then return end local ch,bytes if byte_pos then bytes = utf8charbytes(str,byte_pos) ch = sub(str,byte_pos,byte_pos-1+bytes) else ch,byte_pos = utf8sub(str,i,i), 0 bytes = #ch end local unicode if bytes == 1 then unicode = byte(ch) end if bytes == 2 then local byte0,byte1 = byte(ch,1,2) local code0,code1 = byte0-0xC0,byte1-0x80 unicode = code0*shift_6 + code1 end if bytes == 3 then local byte0,byte1,byte2 = byte(ch,1,3) local code0,code1,code2 = byte0-0xE0,byte1-0x80,byte2-0x80 unicode = code0*shift_12 + code1*shift_6 + code2 end if bytes == 4 then local byte0,byte1,byte2,byte3 = byte(ch,1,4) local code0,code1,code2,code3 = byte0-0xF0,byte1-0x80,byte2-0x80,byte3-0x80 unicode = code0*shift_18 + code1*shift_12 + code2*shift_6 + code3 end return unicode,utf8unicode(str, i+1, J, byte_pos+bytes) end function utf8gensub(str, sub_len) sub_len = sub_len or 1 local byte_pos = 1 local length = #str return function(skip) if skip then byte_pos = byte_pos + skip end local char_count = 0 local start = byte_pos repeat if byte_pos > length then return end char_count = char_count + 1 local bytes = utf8charbytes(str,byte_pos) byte_pos = byte_pos+bytes until char_count == sub_len local last = byte_pos-1 local slice = sub(str,start,last) return slice, start, last end end function binsearch(sortedTable, item, comp) local head, tail = 1, #sortedTable local mid = _G.math.floor((head + tail)/2) if not comp then while (tail - head) > 1 do if sortedTable[_G.tonumber(mid)] > item then tail = mid else head = mid end mid = _G.math.floor((head + tail)/2) end end if sortedTable[_G.tonumber(head)] == item then return true, _G.tonumber(head) elseif sortedTable[_G.tonumber(tail)] == item then return true, _G.tonumber(tail) else return false end end function classMatchGenerator(class, plain) local codes = {} local ranges = {} local ignore = false local range = false local firstletter = true local unmatch = false local it = utf8gensub(class) local skip for c, _, be in it do skip = be if not ignore and not plain then if c == "%" then ignore = true elseif c == "-" then _G.table.insert(codes, utf8unicode(c)) range = true elseif c == "^" then if not firstletter then _G.error('!!!') else unmatch = true end elseif c == ']' then break else if not range then _G.table.insert(codes, utf8unicode(c)) else _G.table.remove(codes) _G.table.insert(ranges, {_G.table.remove(codes), utf8unicode(c)}) range = false end end elseif ignore and not plain then if c == 'a' then _G.table.insert(ranges, {65, 90}) _G.table.insert(ranges, {97, 122}) elseif c == 'c' then _G.table.insert(ranges, {0, 31}) _G.table.insert(codes, 127) elseif c == 'd' then _G.table.insert(ranges, {48, 57}) elseif c == 'g' then _G.table.insert(ranges, {1, 8}) _G.table.insert(ranges, {14, 31}) _G.table.insert(ranges, {33, 132}) _G.table.insert(ranges, {134, 159}) _G.table.insert(ranges, {161, 5759}) _G.table.insert(ranges, {5761, 8191}) _G.table.insert(ranges, {8203, 8231}) _G.table.insert(ranges, {8234, 8238}) _G.table.insert(ranges, {8240, 8286}) _G.table.insert(ranges, {8288, 12287}) elseif c == 'l' then _G.table.insert(ranges, {97, 122}) elseif c == 'p' then _G.table.insert(ranges, {33, 47}) _G.table.insert(ranges, {58, 64}) _G.table.insert(ranges, {91, 96}) _G.table.insert(ranges, {123, 126}) elseif c == 's' then _G.table.insert(ranges, {9, 13}) _G.table.insert(codes, 32) _G.table.insert(codes, 133) _G.table.insert(codes, 160) _G.table.insert(codes, 5760) _G.table.insert(ranges, {8192, 8202}) _G.table.insert(codes, 8232) _G.table.insert(codes, 8233) _G.table.insert(codes, 8239) _G.table.insert(codes, 8287) _G.table.insert(codes, 12288) elseif c == 'u' then _G.table.insert(ranges, {65, 90}) elseif c == 'w' then _G.table.insert(ranges, {48, 57}) _G.table.insert(ranges, {65, 90}) _G.table.insert(ranges, {97, 122}) elseif c == 'x' then _G.table.insert(ranges, {48, 57}) _G.table.insert(ranges, {65, 70}) _G.table.insert(ranges, {97, 102}) else if not range then _G.table.insert(codes, utf8unicode(c)) else _G.table.remove(codes) _G.table.insert(ranges, {_G.table.remove(codes), utf8unicode(c)}) range = false end end ignore = false else if not range then _G.table.insert(codes, utf8unicode(c)) else _G.table.remove(codes) _G.table.insert(ranges, {_G.table.remove(codes), utf8unicode(c)}) range = false end ignore = false end firstletter = false end _G.table.sort(codes) local function inRanges(charCode) for _,r in _G.ipairs(ranges) do if r[1] <= charCode and charCode <= r[2] then return true end end return false end if not unmatch then return function(charCode) return binsearch(codes, charCode) or inRanges(charCode) end, skip else return function(charCode) return charCode ~= -1 and not (binsearch(codes, charCode) or inRanges(charCode)) end, skip end end local cache = _G.setmetatable({},{ __mode = 'kv' }) local cachePlain = _G.setmetatable({},{ __mode = 'kv' }) function matcherGenerator(regex, plain) local matcher = { functions = {}, captures = {} } if not plain then cache[regex] = matcher else cachePlain[regex] = matcher end local function simple(func) return function(cC) if func(cC) then matcher:nextFunc() matcher:nextStr() else matcher:reset() end end end local function star(func) return function(cC) if func(cC) then matcher:fullResetOnNextFunc() matcher:nextStr() else matcher:nextFunc() end end end local function minus(func) return function(cC) if func(cC) then matcher:fullResetOnNextStr() end matcher:nextFunc() end end local function question(func) return function(cC) if func(cC) then matcher:fullResetOnNextFunc() matcher:nextStr() end matcher:nextFunc() end end local function capture(id) return function(_) local l = matcher.captures[id][2] - matcher.captures[id][1] local captured = utf8sub(matcher.string, matcher.captures[id][1], matcher.captures[id][2]) local check = utf8sub(matcher.string, matcher.str, matcher.str + l) if captured == check then for _ = 0, l do matcher:nextStr() end matcher:nextFunc() else matcher:reset() end end end local function captureStart(id) return function(_) matcher.captures[id][1] = matcher.str matcher:nextFunc() end end local function captureStop(id) return function(_) matcher.captures[id][2] = matcher.str - 1 matcher:nextFunc() end end local function balancer(str) local sum = 0 local bc, ec = utf8sub(str, 1, 1), utf8sub(str, 2, 2) local skip = len(bc) + len(ec) bc, ec = utf8unicode(bc), utf8unicode(ec) return function(cC) if cC == ec and sum > 0 then sum = sum - 1 if sum == 0 then matcher:nextFunc() end matcher:nextStr() elseif cC == bc then sum = sum + 1 matcher:nextStr() else if sum == 0 or cC == -1 then sum = 0 matcher:reset() else matcher:nextStr() end end end, skip end matcher.functions[1] = function(_) matcher:fullResetOnNextStr() matcher.seqStart = matcher.str matcher:nextFunc() if (matcher.str > matcher.startStr and matcher.fromStart) or matcher.str >= matcher.stringLen then matcher.stop = true matcher.seqStart = nil end end local lastFunc local ignore = false local skip = nil local it = (function() local gen = utf8gensub(regex) return function() return gen(skip) end end)() local cs = {} for c, bs, be in it do skip = nil if plain then _G.table.insert(matcher.functions, simple(classMatchGenerator(c, plain))) else if ignore then if find('123456789', c, 1, true) then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) lastFunc = nil end _G.table.insert(matcher.functions, capture(_G.tonumber(c))) elseif c == 'b' then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) lastFunc = nil end local b b, skip = balancer(sub(regex, be + 1, be + 9)) _G.table.insert(matcher.functions, b) else lastFunc = classMatchGenerator('%' .. c) end ignore = false else if c == '*' then if lastFunc then _G.table.insert(matcher.functions, star(lastFunc)) lastFunc = nil else _G.error('invalid regex after ' .. sub(regex, 1, bs)) end elseif c == '+' then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) _G.table.insert(matcher.functions, star(lastFunc)) lastFunc = nil else _G.error('invalid regex after ' .. sub(regex, 1, bs)) end elseif c == '-' then if lastFunc then _G.table.insert(matcher.functions, minus(lastFunc)) lastFunc = nil else _G.error('invalid regex after ' .. sub(regex, 1, bs)) end elseif c == '?' then if lastFunc then _G.table.insert(matcher.functions, question(lastFunc)) lastFunc = nil else _G.error('invalid regex after ' .. sub(regex, 1, bs)) end elseif c == '^' then if bs == 1 then matcher.fromStart = true else _G.error('invalid regex after ' .. sub(regex, 1, bs)) end elseif c == '$' then if be == len(regex) then matcher.toEnd = true else _G.error('invalid regex after ' .. sub(regex, 1, bs)) end elseif c == '[' then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) end lastFunc, skip = classMatchGenerator(sub(regex, be + 1)) elseif c == '(' then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) lastFunc = nil end _G.table.insert(matcher.captures, {}) _G.table.insert(cs, #matcher.captures) _G.table.insert(matcher.functions, captureStart(cs[#cs])) if sub(regex, be + 1, be + 1) == ')' then matcher.captures[#matcher.captures].empty = true end elseif c == ')' then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) lastFunc = nil end local cap = _G.table.remove(cs) if not cap then _G.error('invalid capture: "(" missing') end _G.table.insert(matcher.functions, captureStop(cap)) elseif c == '.' then if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) end lastFunc = function(cC) return cC ~= -1 end elseif c == '%' then ignore = true else if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) end lastFunc = classMatchGenerator(c) end end end end if #cs > 0 then _G.error('invalid capture: ")" missing') end if lastFunc then _G.table.insert(matcher.functions, simple(lastFunc)) end _G.table.insert(matcher.functions, function() if matcher.toEnd and matcher.str ~= matcher.stringLen then matcher:reset() else matcher.stop = true end end) matcher.nextFunc = function(self) self.func = self.func + 1 end matcher.nextStr = function(self) self.str = self.str + 1 end matcher.strReset = function(self) local oldReset = self.reset local str = self.str self.reset = function(s) s.str = str s.reset = oldReset end end matcher.fullResetOnNextFunc = function(self) local oldReset = self.reset local func = self.func +1 local str = self.str self.reset = function(s) s.func = func s.str = str s.reset = oldReset end end matcher.fullResetOnNextStr = function(self) local oldReset = self.reset local str = self.str + 1 local func = self.func self.reset = function(s) s.func = func s.str = str s.reset = oldReset end end matcher.process = function(self, str, start) self.func = 1 start = start or 1 self.startStr = (start >= 0) and start or utf8len(str) + start + 1 self.seqStart = self.startStr self.str = self.startStr self.stringLen = utf8len(str) + 1 self.string = str self.stop = false self.reset = function(s) s.func = 1 end local ch while not self.stop do if self.str < self.stringLen then ch = utf8sub(str, self.str,self.str) self.functions[self.func](utf8unicode(ch)) else self.functions[self.func](-1) end end if self.seqStart then local captures = {} for _,pair in _G.pairs(self.captures) do if pair.empty then _G.table.insert(captures, pair[1]) else _G.table.insert(captures, utf8sub(str, pair[1], pair[2])) end end return self.seqStart, self.str - 1, _G.unpack(captures) end end return matcher end function utf8find(str, regex, init, plain) local matcher = cache[regex] or matcherGenerator(regex, plain) return matcher:process(str, init) end function utf8match(str, regex, init) init = init or 1 local found = {utf8find(str, regex, init)} if found[1] then if found[3] then return _G.unpack(found, 3) end return utf8sub(str, found[1], found[2]) end end function utf8gmatch(str, regex, all) regex = (utf8sub(regex,1,1) ~= '^') and regex or '%' .. regex local lastChar = 1 return function() local found = {utf8find(str, regex, lastChar)} if found[1] then lastChar = found[2] + 1 if found[all and 1 or 3] then return _G.unpack(found, all and 1 or 3) end return utf8sub(str, found[1], found[2]) end end end function replace(repl, args) local ret = '' if _G.type(repl) == 'string' then local ignore = false local num for c in utf8gensub(repl) do if not ignore then if c == '%' then ignore = true else ret = ret .. c end else num = _G.tonumber(c) if num then ret = ret .. args[num] else ret = ret .. c end ignore = false end end elseif _G.type(repl) == 'table' then ret = repl[args[1] or args[0]] or '' elseif _G.type(repl) == 'function' then if #args > 0 then ret = repl(_G.unpack(args, 1)) or '' else ret = repl(args[0]) or '' end end return ret end function utf8gsub(str, regex, repl, limit) limit = limit or -1 local ret = '' local prevEnd = 1 local it = utf8gmatch(str, regex, true) local found = {it()} local n = 0 while #found > 0 and limit ~= n do local args = {[0] = utf8sub(str, found[1], found[2]), _G.unpack(found, 3)} ret = ret .. utf8sub(str, prevEnd, found[1] - 1) .. replace(repl, args) prevEnd = found[2] + 1 n = n + 1 found = {it()} end return ret .. utf8sub(str, prevEnd), n end utf8 = {} utf8.len = utf8len utf8.sub = utf8sub utf8.reverse = utf8reverse utf8.char = utf8char utf8.unicode = utf8unicode utf8.gensub = utf8gensub utf8.byte = utf8unicode utf8.find = utf8find utf8.match = utf8match utf8.gmatch = utf8gmatch utf8.gsub = utf8gsub utf8.dump = dump utf8.format = format utf8.lower = lower utf8.upper = upper utf8.rep = rep return utf8]===]
	
		elseif l.effect == "lighting" then
			l.text=[===[function lighting(x1,y1,x2,y2,displace,curDetail,thickness_min,thickness_max) pos_table = {} pos_table_temp = {} shape_table = {} shape_table_reverse = {} local function drawLightning(x1,y1,x2,y2,displace) if (displace < curDetail) then pos_table[#pos_table+1] = {x1,y1,x2,y2} else local mid_x = (x1+x2)/2 local mid_y = (y1+y2)/2 mid_x = mid_x + (math.random(0,1)-0.5) * displace mid_y = mid_y + (math.random(0,1)-0.5) * displace drawLightning(x1,y1,mid_x,mid_y,displace/2) drawLightning(mid_x,mid_y,x2,y2,displace/2) end end do drawLightning(x1,y1,x2,y2,displace) end for var=1,#pos_table do shape_table[var] = _G.table.concat(pos_table[var]," ",3,4) pos_table_temp[var] = {} pos_table_temp[var][3] = pos_table[var][3] pos_table_temp[var][4] = pos_table[var][4]+math.random(thickness_min,thickness_max) shape_table_reverse[#pos_table-var+1] = _G.table.concat(pos_table_temp[var]," ",3,4) end return string.format("m %d %d l ",x1,y1).._G.table.concat(shape_table," ").." ".._G.table.concat(shape_table_reverse," ") end]===]
	
		end
		l.effect="code once"
		l.comment = true
		subtitles[i] = l
	end
end

aegisub.register_macro(script_name, script_description, add_function)